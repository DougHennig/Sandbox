*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="xxx.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS sfspinner AS spinner 		&& The base class for all Spinner objects
 	*< CLASSDATA: Baseclass="spinner" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "source\sfctrls.h"
	*<DefinedPropArrayMethod>
		*m: about		&& Provides documentation for the class
		*m: adjustselstart		&& Adjust SelStart as necessary
		*m: anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		*m: lsaveanchor_assign
		*m: nhighvalue_assign
		*m: nlowvalue_assign
		*m: onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		*m: release		&& Releases the object
		*m: setcalcvalues		&& Handles changes to any of the "calculator" properties
		*m: shortcutmenu		&& Populates the shortcut menu
		*m: showmenu		&& Display a shortcut menu
		*m: updatecontrolsource		&& Updates the ControlSource with the new value
		*m: validation		&& An abstract method for custom validation code
		*p: builder		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
		*p: cinputmask		&& The saved InputMask
		*p: csign		&& The saved sign of the value
		*p: lbindtoformanychange		&& .T. to bind this control's AnyChange event to its form's AnyChange method
		*p: lcalculator		&& .T. to use calculator-style digit entry
		*p: lhasdecimal		&& .T. if the value has a decimal part
		*p: lhasinteger		&& .T. if the value has an integer part
		*p: lindecimalpart		&& .T. if the cursor is in the decimal part of the value
		*p: lnotifyonformchange		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
		*p: lsaveanchor		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
		*p: lskipvalidonformclose		&& .T. if we can skip validating this control when the form is closed
		*p: lupdatecontrolsource		&& .T. if UpdateControlSource should be called from InteractiveChange
		*p: luseformshortcutmenu		&& .T. if the form's shortcut menu items should be included with this object's
		*p: nhighvalue		&& The maximum value
		*p: nlowvalue		&& The minimum value
		*p: nsavedanchor		&& The anchor value saved in lSaveAnchor_Assign
		*p: nselstart		&& The saved value of SelStart
		*p: oexception		&& A reference to an Exception object
		*p: ohook		&& A reference to a hooked object
		*p: omenu		&& A reference to an SFShortcutMenu object
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED cinputmask,csign,lhasdecimal,lhasinteger,lindecimalpart,nsavedanchor,nselstart
	builder = 		&& Tells BUILDER.APP the name of a specific builder to use for this class (specified as Library,Class)
	cinputmask = 		&& The saved InputMask
	csign = 		&& The saved sign of the value
	FontName = "Tahoma"
	lbindtoformanychange = .F.		&& .T. to bind this control's AnyChange event to its form's AnyChange method
	lcalculator = .T.		&& .T. to use calculator-style digit entry
	lhasdecimal = .F.		&& .T. if the value has a decimal part
	lhasinteger = .T.		&& .T. if the value has an integer part
	lindecimalpart = .F.		&& .T. if the cursor is in the decimal part of the value
	lnotifyonformchange = .F.		&& .T. if the OnFormChanged method of this control is bound to the lChanged property of the form
	lsaveanchor = .F.		&& This allows a container to use SetAll('lSaveAnchor') to save/reset and then restore Anchor when the form's size is changed but controls shouldn't move
	lskipvalidonformclose = .T.		&& .T. if we can skip validating this control when the form is closed
	lupdatecontrolsource = .T.		&& .T. if UpdateControlSource should be called from InteractiveChange
	luseformshortcutmenu = .F.		&& .T. if the form's shortcut menu items should be included with this object's
	Name = "sfspinner"
	nhighvalue = 999999999		&& The maximum value
	nlowvalue = -99999999		&& The minimum value
	nsavedanchor = 0		&& The anchor value saved in lSaveAnchor_Assign
	nselstart = 0		&& The saved value of SelStart
	oexception = .NULL.		&& A reference to an Exception object
	ohook = .NULL.		&& A reference to a hooked object
	omenu = .NULL.		&& A reference to an SFShortcutMenu object
	SelectOnEntry = .T.
	_memberdata = <VFPData>
		<memberdata name="about" type="method" display="About"/>
		<memberdata name="adjustselstart" type="method" display="AdjustSelStart"/>
		<memberdata name="anychange" type="method" display="AnyChange" favorites="True"/>
		<memberdata name="builder" type="property" display="Builder"/>
		<memberdata name="cinputmask" type="property" display="cInputMask"/>
		<memberdata name="csign" type="property" display="cSign"/>
		<memberdata name="lcalculator" type="property" display="lCalculator" favorites="True"/>
		<memberdata name="lhasdecimal" type="property" display="lHasDecimal"/>
		<memberdata name="lhasinteger" type="property" display="lHasInteger"/>
		<memberdata name="lindecimalpart" type="property" display="lInDecimalPart"/>
		<memberdata name="lskipvalidonformclose" type="property" display="lSkipValidOnFormClose" favorites="True"/>
		<memberdata name="luseformshortcutmenu" type="property" display="lUseFormShortcutMenu" favorites="True"/>
		<memberdata name="nhighvalue" type="property" display="nHighValue" favorites="True"/>
		<memberdata name="nhighvalue_assign" type="method" display="nHighValue_Assign"/>
		<memberdata name="nlowvalue" type="property" display="nLowValue" favorites="True"/>
		<memberdata name="nlowvalue_assign" type="method" display="nLowValue_Assign"/>
		<memberdata name="nselstart" type="property" display="nSelStart"/>
		<memberdata name="oexception" type="property" display="oException"/>
		<memberdata name="ohook" type="property" display="oHook"/>
		<memberdata name="omenu" type="property" display="oMenu"/>
		<memberdata name="release" type="method" display="Release"/>
		<memberdata name="setcalcvalues" type="method" display="SetCalcValues"/>
		<memberdata name="shortcutmenu" type="method" display="ShortcutMenu" favorites="True"/>
		<memberdata name="showmenu" type="method" display="ShowMenu"/>
		<memberdata name="validation" type="method" display="Validation" favorites="True"/>
		<memberdata name="lsaveanchor" type="property" display="lSaveAnchor"/>
		<memberdata name="lsaveanchor_assign" type="property" display="lSaveAnchor_Assign"/>
		<memberdata name="nsavedanchor" type="property" display="nSavedAnchor"/>
		<memberdata name="lbindtoformanychange" type="property" display="lBindToFormAnyChange"/>
		<memberdata name="lnotifyonformchange" type="property" display="lNotifyOnFormChange"/>
		<memberdata name="onformchange" type="method" display="OnFormChange"/>
		<memberdata name="updatecontrolsource" type="method" display="UpdateControlSource"/>
		<memberdata name="lupdatecontrolsource" type="property" display="lUpdateControlSource"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE about		&& Provides documentation for the class
		*==============================================================================
		* Class:						SFSpinner
		* Based On:						Spinner
		* Purpose:						The base class for all Spinner objects
		* Author:						Doug Hennig. "Calculator-style" entry based on
		*								code by Marcelo Ris published in FoxPro
		*								Advisor, June 1999
		* Copyright:					(c) 1996-2014 Stonefield Systems Group Inc.
		* Last revision:				10/07/2014
		* Include file:					SFCtrls.H
		*
		* Changes in "Based On" class properties:
		*	FontName:					Tahoma
		*	SelectOnEntry:				.T.
		*
		* Changes in "Based On" class methods:
		*	Click:						if we're acting like a calculator, make any
		*								necessary adjustments to SelStart
		*	Destroy:					nukes member objects
		*	Error:						calls the parent Error method so error handling
		*								goes up the containership hierarchy
		*	GotFocus:					if we're acting like a calculator, adjust
		*								SelStart to be in the integer part
		*	Init:						initialize "calculator" values. Bind
		*								InteractiveChange to the form's AnyChange
		*								method and bind OnFormChange to the form's
		*								lChanged property if necessary. Change FontName
		*								to Segoe UI in Vista
		*	InteractiveChange:			set SelStart to its saved value and make any
		*								necessary adjustments, then raise the AnyChange
		*								event
		*	KeyPress:					handle calculator-style entry
		*	ProgrammaticChange:			set SelStart to its saved value and make any
		*								necessary adjustments, then raise the AnyChange
		*								event
		*	RightClick:					calls This.ShowMenu
		*	Valid:						prevent validation code from executing if the
		*								user is cancelling, retain focus if a field
		*								rule failed, and call the custom Validation
		*								method
		*
		* Custom public properties added:
		*	Builder:					tells BUILDER.APP the name of a specific
		*								builder to use for this class (specified as
		*								Library,Class)
		*	lBindToFormAnyChange:		.T. to bind this control's AnyChange event to
		*								its form's AnyChange method
		*	lCalculator:				.T. to use calculator-style digit entry
		*	lNotifyOnFormChange:		.T. if the OnFormChanged method of this control
		*								is bound to the lChanged property of the form
		*	lSaveAnchor:				this allows a container to use
		*								SetAll('lSaveAnchor') to save/reset and then
		*								restore Anchor when the form's size is changed
		*								but controls shouldn't move
		*	lSkipValidOnFormClose:		.T. if we can skip validating this control when
		*								the form is closed
		*	lUpdateControlSource:		.T. if UpdateControlSource should be called
		*								from InteractiveChange
		*	lUseFormShortcutMenu:		.T. if the form's shortcut menu items should be
		*								included with this object's
		*	nHighValue:					the maximum value (Assign calls SetCalcValues)
		*	nLowValue:					the minimum value (Assign calls SetCalcValues)
		*	oException:					a reference to an Exception object
		*	oHook:						a reference to a hooked object
		*	oMenu:						a reference to an SFShortcutMenu object
		*
		* Custom protected properties added:
		*	cInputMask:					the saved InputMask
		*	cSign:						the saved sign of the value
		*	lHasDecimal:				.T. if the value has a decimal part
		*	lHasInteger:				.T. if the value has an integer part
		*	lInDecimalPart:				.T. if the cursor is in the decimal part of the
		*								value
		*	nSavedAnchor:				the anchor value saved in lSaveAnchor_Assign
		*	nSelStart:					the saved value of SelStart
		*
		* Custom public methods added:
		*	About:						provides documentation for the class
		*	AnyChange:					called from the InteractiveChange and
		*								ProgrammaticChange events to consolidate
		*								change code in one place
		*	OnFormChange:				fired when the lChanged property of the form
		*								changes if lNotifyOnFormChange is .T.
		*	Release:					releases the object
		*	SetCalcValues:				handles changes to any of the "calculator"
		*								properties
		*	ShortcutMenu:				populates the shortcut menu
		*	ShowMenu:					display a shortcut menu
		*	UpdateControlSource:		updates the ControlSource with the new value
		*	Validation:					abstract method for custom validation code
		*
		* Custom protected methods added:
		*	AdjustSelStart:				adjust SelStart as necessary
		*==============================================================================
		
	ENDPROC

	PROTECTED PROCEDURE adjustselstart		&& Adjust SelStart as necessary
		lparameters tnMove
		local lnLen, ;
			lcText1, ;
			lcText2, ;
			lnMin, ;
			lnSelStart, ;
			lnMove, ;
			lnSelLength, ;
			lnPos, ;
			lnChar
		with This
		
		* Calculate the minimum position for the cursor by removing any non-digit
		* characters from the InputMask.
		
			lnLen   = len(.InputMask)
			lcText1 = .Text
			lcText2 = ltrim(lcText1)
			do while not empty(lcText2) and not isdigit(left(lcText2, 1))
				lcText2 = ltrim(right(lcText2, len(lcText2) - 1))
			enddo while not empty(lcText2) ...
			lnMin = len(lcText1) - len(lcText2)
		
		* Calculate the the new cursor position, keeping it between the maximum and
		* minimum values.
		
			lnSelStart = .SelStart + tnMove
			do case
				case lnSelStart < lnMin
					lnSelStart = lnMin
					lnMove     = 0
				case lnSelStart > lnLen
					lnSelStart = lnLen
					lnMove     = 0
				otherwise
					lnMove = tnMove
			endcase
		
		* Depending on whether we're moving positive or negative, move the cursor right
		* or left every time there is a non-digit on the left.
		
			if lnMove >= 0
				do while lnSelStart < lnLen and ;
					substr(.InputMask, lnSelStart + 1, 1) <> '9'
					lnSelStart = lnSelStart + 1
				enddo while lnSelStart < lnLen ...
			else
				do while lnSelStart > lnMin and ;
					substr(.InputMask, lnSelStart + 1, 1) <> '9'
					lnSelStart = lnSelStart - 1
				enddo while lnSelStart > lnMin ...
			endif lnMove >= 0
		
		* Adjust SelLength as necessary, then adjust SelStart to the new position.
		
			lnSelLength = .SelLength
			if lnSelLength > 0
				lnSelLength = max(lnSelLength - (lnSelStart - .SelStart), 0)
			endif lnSelLength > 0
			.SelStart  = lnSelStart
			.nSelStart = lnSelStart
			.SelLength = lnSelLength
		
		* Set the spinner's increment to the value (integer or decimal) corresponding
		* to the left position of the cursor.
		
			lnPos   = lnSelStart + 1
			lnChar  = 1
			lcText1 = .InputMask
			do while lnChar <= len(lcText1) 
				lcText2 = substr(lcText1, lnChar, 1)
				do case
					case lcText2 = '.'
						if lnChar <= lnSelStart
							lnPos = lnPos - 1
						endif lnChar <= lnSelStart
						lnChar = lnChar + 1
			      	case not isdigit(lcText2)
						if lnChar <= lnSelStart
							lnPos = lnPos - 1
						endif lnChar <= lnSelStart
						lcText1    = stuff(lcText1, lnChar, 1, '')
						lnSelStart = lnSelStart - 1
					otherwise
						lnChar = lnChar + 1
				endcase
			enddo while lnChar <= len(lcText1) 
			.Increment = val(strtran(stuff(lcText1, lnPos, 0, '1'), '9', '0'))
		endwith
		
	ENDPROC

	PROCEDURE anychange		&& Called from the InteractiveChange and ProgrammaticChange events to consolidate change code in one place
		* Abstract method
		
	ENDPROC

	PROCEDURE Click
		* If we're acting like a calculator, make any necessary adjustments to
		* SelStart.
		
		with This
			if .lCalculator
				.AdjustSelStart(0)
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oHook = .NULL.
		This.oMenu = .NULL.
		
	ENDPROC

	PROCEDURE Error
		*==============================================================================
		* Method:			Error
		* Status:			Public
		* Purpose:			Handles errors
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	12/15/2005
		* Parameters:		tnError  - the error number
		*					tcMethod - the method that caused the error
		*					tnLine   - the line number of the command in error 
		* Returns:			may return an error resolution string (see SFERRORS.H for
		*						a list) or may RETURN, RETRY, or CANCEL
		* Environment in:	if a global error handler object exists, it's in the global
		*						variable oError
		*					a global ON ERROR routine may be in effect
		* Environment out:	depends on the error resolution chosen
		*==============================================================================
		
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local lnError, ;
			lcMethod, ;
			lnLine, ;
			lcSource, ;
			laError[1], ;
			lcName, ;
			lcOrigMethod, ;
			loParent, ;
			lcReturn, ;
			lcError, ;
			lcMessage, ;
			lnChoice
		
		* Use AERROR() to get information about the error. If we have an Exception
		* object in oException, get information about the error from it.
		
		lnError  = tnError
		lcMethod = tcMethod
		lnLine   = tnLine
		lcSource = message(1)
		aerror(laError)
		with This
			if vartype(.oException) = 'O'
				lnError  = .oException.ErrorNo
				lcMethod = .oException.Procedure
				lnLine   = .oException.LineNo
				lcSource = .oException.LineContents
				laError[cnAERR_NUMBER]  = .oException.ErrorNo
				laError[cnAERR_MESSAGE] = .oException.Message
				laError[cnAERR_OBJECT]  = .oException.Details
				.oException = .NULL.
			endif vartype(.oException) = 'O'
		endwith
		
		* Determine which method of which object the error occurred in. If the error
		* occurred in a child object, the method may already have our name on it, so
		* handle that.
		
		lcName   = upper(This.Name) + '.'
		lcMethod = upper(tcMethod)
		if lcMethod = lcName or '.' + lcName $ lcMethod
			lcOrigMethod = substr(tcMethod, rat('.', tcMethod) + 1)
		else
			lcOrigMethod = tcMethod
		endif lcMethod = lcName ...
		lcMethod = This.Name + '.' + lcOrigMethod
		
		* If we're sitting on a form and that form has a FindErrorHandler method, call
		* it to travel up the containership hierarchy until we find a parent that has
		* code in its Error method. Also, if it has a SetError method, call it now so
		* we don't lose the message information (which gets messed up by TYPE()).
		
		if type('Thisform') = 'O'
			loParent = iif(pemstatus(Thisform, 'FindErrorHandler', 5), ;
				Thisform.FindErrorHandler(This), .NULL.)
			if pemstatus(Thisform, 'SetError', 5)
				Thisform.SetError(lcMethod, lnLine, lcSource, @laError)
			endif pemstatus(Thisform, 'SetError', 5)
		else
			loParent = .NULL.
		endif type('Thisform') = 'O'
		do case
		
		* We have a parent that can handle the error.
		
			case not isnull(loParent)
				lcReturn = loParent.Error(lnError, lcMethod, lnLine)
		
		* We have an error handling object, so call its ErrorHandler() method.
		
			case type('oError.Name') = 'C' and pemstatus(oError, 'ErrorHandler', 5)
				if pemstatus(oError, 'SetError', 5)
					oError.SetError(lcMethod, lnLine, lcSource, @laError)
				endif pemstatus(oError, 'SetError', 5)
				lcReturn = oError.ErrorHandler(lnError, lcMethod, lnLine)
		
		* A global error handler is in effect, so let's pass the error on to it.
		* Replace certain parameters passed to the error handler (the name of the
		* program, the error number, the line number, the message, and SYS(2018)) with
		* the appropriate values.
		
			case not empty(on('ERROR'))
				lcError = upper(on('ERROR'))
				lcError = strtran(lcError, 'SYS(16)',   '"' + lcMethod + '"')
				lcError = strtran(lcError, 'PROGRAM()', '"' + lcMethod + '"')
				lcError = strtran(lcError, ',ERROR()',  ',lnError')
				lcError = strtran(lcError, ' ERROR()',  ' lnError')
				lcError = strtran(lcError, 'LINENO()',  'lnLine')
				lcError = strtran(lcError, 'MESSAGE()', 'laError[2]')
				lcError = strtran(lcError, 'SYS(2018)', 'laError[3]')
		
		* If the error handler is called with DO, macro expand it and assume the return
		* value is "CONTINUE". If the error handler is called as a function (such as an
		* object method), call it and grab the return value if there is one.
		
				if left(lcError, 3) = 'DO ' or '=' $ lcError
					&lcError
					lcReturn = ccMSG_CONTINUE
				else
					lcReturn = &lcError
				endif left(lcError, 3) = 'DO ' ...
		
		* Display a generic dialog box with an option to display the debugger (this
		* should only occur in a test environment).
		
			otherwise
				lcSource  = message(1)
				lcMessage = ccMSG_ERROR_NUM + ' ' + transform(lnError) + ccCR + ;
					ccMSG_MESSAGE + ' ' + laError[cnAERR_MESSAGE] + ccCR + ;
					iif(empty(lcSource), '', ccMSG_CODE + ' ' + lcSource + ;
					ccCR) + iif(lnLine = 0, '', ccMSG_LINE_NUM + ' ' + ;
					transform(lnLine) + ccCR) + ccMSG_METHOD + ' ' + lcMethod
				if version(2) = 0
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose OK to continue or Cancel to cancel execution', ;
						MB_OKCANCEL + MB_ICONSTOP, _VFP.Caption)
				else
					lnChoice = messagebox(lcMessage + ccCR + ccCR + ;
						'Choose Yes to display the debugger, No to continue ' + ;
						'without the debugger, or Cancel to cancel execution', ;
						MB_YESNOCANCEL + MB_ICONSTOP, _VFP.Caption)
				endif version(2) = 0
				do case
					case lnChoice = IDYES
						lcReturn = ccMSG_DEBUG
					case lnChoice = IDCANCEL
						lcReturn = ccMSG_CANCEL
				endcase
		endcase
		
		* Ensure the return message is acceptable. If not, assume "CONTINUE".
		
		lcReturn = iif(vartype(lcReturn) <> 'C' or empty(lcReturn) or ;
			not lcReturn $ ccMSG_CONTINUE + ccMSG_RETRY + ccMSG_CANCEL + ccMSG_DEBUG, ;
			ccMSG_CONTINUE, lcReturn)
		
		* Handle the return value.
		
		do case
		
		* It wasn't our error, so pass it back to the calling method.
		
			case '.' $ lcOrigMethod
				return lcReturn
		
		* Display the debugger.
		
			case lcReturn = ccMSG_DEBUG
				debug
				if wexist('Visual FoxPro Debugger')
					keyboard '{SHIFT+F7}' plain
				endif wexist('Visual FoxPro Debugger')
				suspend
		
		* Retry the command.
		
			case lcReturn = ccMSG_RETRY
				retry
		
		* Cancel execution.
		
			case lcReturn = ccMSG_CANCEL
				cancel
		
		* Go to the line of code following the error.
		
			otherwise
				return
		endcase
		
	ENDPROC

	PROCEDURE GotFocus
		with This
		
		* If we're acting like a calculator, adjust SelStart to be in the integer part.
		
			if .lCalculator
				if .lHasDecimal
					.AdjustSelStart(at('.', .InputMask) - .SelStart)
				else
					.AdjustSelStart(len(.InputMask) - .SelStart)
				endif .lHasDecimal
				.lInDecimalPart = not .lHasInteger
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE Init
		local loParent
		with This
		
		* Change the font to Segoe UI in Vista.
		
			if os(3) >= '6' and .FontName = 'Tahoma'
				.FontName = 'Segoe UI'
			endif os(3) >= '6' ...
		
		* Initialize "calculator" properties.
		
			.SetCalcValues()
		
		* If we're supposed to bind our AnyChange event to our form's AnyChange method,
		* do so.
		
			if .lBindToFormAnyChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'AnyChange', 5)
				bindevent(This, 'InteractiveChange', Thisform, 'AnyChange', 1)
			endif .lBindToFormAnyChange ...
		
		* If we're supposed to bind to the lChanged property of the form, do so.
		
			if .lNotifyOnFormChange and vartype(Thisform) = 'O' and ;
				pemstatus(Thisform, 'lChanged', 5)
				bindevent(Thisform, 'lChanged', This, 'OnFormChange', 1)
			endif .lNotifyOnFormChange ...
		endwith
		
	ENDPROC

	PROCEDURE InteractiveChange
		with This
		
		* If we're acting like a calculator, set SelStart to its saved value and then
		* make any necessary adjustments.
		
			if .lCalculator
				.SelStart = .nSelStart
				.AdjustSelStart(0)
			endif .lCalculator
		
		* Update the control source in case something binding to our AnyChange event
		* looks at it.
		
			if .lUpdateControlSource
				.UpdateControlSource()
			endif .lUpdateControlSource
		
		* Call a common method for handling changes.
		
			raiseevent(This, 'AnyChange')
		endwith
		
	ENDPROC

	PROCEDURE KeyPress
		lparameters tnKeyCode, ;
			tnShiftAltCtrl
		local lnSelEnd, ;
			lcString, ;
			lnPos, ;
			llIntPart, ;
			lnLen, ;
			lnI, ;
			lcChar, ;
			lnAddSelStart, ;
			lnValue, ;
			llIntFull, ;
			lnDecPos, ;
			llChanged, ;
			llOtherWise, ;
			llNoDefault
		
		* Prevent Ctrl-0 from inserting a null value.
		
		if tnKeyCode = asc('0') and bittest(tnShiftAltCtrl, 1)
			nodefault
			return
		endif tnKeyCode = asc('0') ...
		with This
			if .lCalculator
		
		* If some characters are selected and the user entered a digit or hit Del,
		* replace the selected characters with the input key.
		
				if .SelLength > 0 and (between(tnKeyCode, 48, 57) or ;
					tnKeyCode = 7) and tnShiftAltCtrl = 0
					lnSelEnd  = .SelStart + .SelLength
					lcString  = .Text
					lnPos     = 1
					llIntPart = .T.
					lnLen     = len(.InputMask)
		   
		* Remove the selected characters from the value.
		
					for lnI = 1 to lnLen
						lcChar = substr(.InputMask, lnI, 1)
						do case
							case not inlist(lcChar, '.', '-', ' ') and ;
								not isdigit(lcChar)
								lcString = stuff(lcString, lnPos, 1, '')
							case lcChar = '.'
								llIntPart = .F.
								lnPos     = lnPos + 1
							case not between(lnI, .SelStart + 1, lnSelEnd)
								lnPos = lnPos + 1
							case llIntPart
								lcString = stuff(lcString, lnPos, 1, '')
							otherwise
								lcString = stuff(lcString, lnPos, 1, '0')
								lnPos    = lnPos + 1
						endcase
					next lnI
		
		* Recalculate the SelStart position.
		
					lnAddSelStart = 0
					lnPos         = at('.', .InputMask)
					do case
						case lnPos = 0
							lnAddSelStart = .SelLength
						case between(lnPos, .SelStart + 1, lnSelEnd)
							lnAddSelStart = lnPos - .SelStart
						case lnPos > lnSelEnd
							lnAddSelStart = .SelLength
					endcase
		
		* Save the new value and adjust the cursor position.
		
					lnPos     = .SelStart
					.Value    = val(lcString)
					.SelStart = lnPos
					.AdjustSelStart(lnAddSelStart - (.SelStart - lnPos))
		
		* If the user hit Del, we're done.
		
					if tnKeyCode = 7
						nodefault
						.InteractiveChange()
						return
					endif tnKeyCode = 7
				endif .SelLength > 0 ...
		
		* Save the sign if the value is non-zero.
		
				do case
					case .Value = 0
					case .Value > 0
						.cSign = ''
					otherwise
						.cSign = '-'
				endcase
		
		* Save the value, then remove non-digit characters, and substitute the cursor
		* position with CHR(1).
		
				lnValue  = .Value
				lcString = stuff(.Text, .SelStart + 1, 0, chr(1))
				lnPos    = 1
				do while lnPos <= len(lcString)
					lcChar = substr(lcString, lnPos, 1)
					if not inlist(lcChar, '.', '-', ' ', chr(1)) and ;
						not isdigit(lcChar)
						lcString = stuff(lcString, lnPos, 1, '')
					else
						lnPos = lnPos + 1
					endif not inlist(lcChar ...
				enddo while lnPos <= len(lcString)
		
		* See if the integer part is full.
		
				llIntFull = len(lcString) = len(ltrim(lcString))
				lcString  = alltrim(lcString)
		
		* Find the cursor position and remove it, then save the decimal position.
		
				lnPos    = at(chr(1), lcString) - 1
				lcString = strtran(lcString, chr(1))
				lnDecPos = at('.', lcString)
		
		* See if the cursor is in the decimal or integer position.
		
				do case
					case not .lHasDecimal
						.lInDecimalPart = .F.
					case lnPos > lnDecPos or (lnPos = lnDecPos and llIntFull)
						.lInDecimalPart = .T.
					case lnPos < lnDecPos and .lHasInteger
						.lInDecimalPart = .F.
				endcase
		
		* Process things depending on what key the user hit.
		
				lnAddSelStart = 0
				llChanged     = .F.
				llOtherwise   = .F.
				lnValue       = val(lcString)
				do case
		
		* "0" to "9": enter the digit.
		
					case between(tnKeyCode, 48, 57) and tnShiftAltCtrl = 0
						nodefault
						llNoDefault = .T.
						do case
		
		* If we're in the integer part and it isn't full, insert the character in the
		* integer part.
		
							case not .lInDecimalPart and not llIntFull
								if lnPos = lnDecPos
									lnPos = lnPos - 1
								endif lnPos = lnDecPos
								lcString  = stuff(lcString, lnPos + 1, 0, ;
									chr(tnKeyCode))
								lnValue   = val(lcString)
								llChanged = .T.
		
		* We're not at the end of the decimal area yet, so overwrite it.
		
				         	case .SelStart < len(.InputMask)
								lcString      = stuff(lcString, lnPos + 1, 1, ;
									chr(tnKeyCode))
								lnAddSelStart = 1
								lnValue       = val(lcString)
								llChanged     = .T.
						endcase
		
		* Backspace: remove the digit to the left if there is one.
		
					case tnKeyCode = 127
						nodefault
						llNoDefault = .T.
						if lnPos > 0
		
		* If we have an integer part and we're at the decimal point, move to the left
		* to put the cursor in a valid position.
		
							if .lHasInteger and substr(lcString, lnPos, 1) = '.'
								lnPos = lnPos - 1
								.lInDecimalPart = .F.
							endif .lHasInteger ...
		
		* If there is a digit on the left, remove it.
		
							if lnPos > 0 and ;
								not inlist(substr(lcString, lnPos, 1), '-', '.')
								lcString = stuff(lcString, lnPos, 1, '')
		
		* If we're at the decimal part, move the cursor to the left.
		
								if .lInDecimalPart
									lnAddSelStart = -1
								endif .lInDecimalPart
								lnValue   = val(lcString)
								llChanged = .T.
							endif lnPos > 0 ...
						endif lnPos > 0
		
		* Del: remove the digit to the right if there is one.
		
					case tnKeyCode = 7
						nodefault
						llNoDefault = .T.
						if lnPos < len(lcString) and substr(lcString, lnPos, 1) <> '-'
		
		* If we're at the decimal point and have a decimal part, put the cursor at it.
		
							if .lHasDecimal and substr(lcString, lnPos, 1) = '.'
								.lInDecimalPart = .T.
							endif .lHasDecimal ...
		
		* Remove the character after the cursor. If it's at the integer part, move to
		* the right.
		
							lcString = stuff(lcString, lnPos + 1, 1, '')
							if not .lInDecimalPart
								lnAddSelStart = 1
							endif not .lInDecimalPart
							lnValue   = val(lcString)
							llChanged = .T.
						endif lnPos < len(lcString) ...
		
		* "C": set the value to zero.
		
					case inlist(tnKeyCode, 67, 99) and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						llNoDefault = .T.
						.cSign      = ''
						lnValue     = 0.0000
						llChanged   = .T.
						if .lHasDecimal
							lnAddSelStart = at('.', .InputMask) - .SelStart
						else
							lnAddSelStart = len(.InputMask) - .SelStart
						endif .lHasDecimal
						.lInDecimalPart = not .lHasInteger
		
		* +: change to positive.
		
					case tnKeyCode = 43 and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						llNoDefault = .T.
						if .SpinnerHighValue < 0
							.cSign = '-'
							if lnValue > 0
								lnValue   = -lnValue
								llChanged = .T.
							endif lnValue > 0
						else
							.cSign = ''
							if lnValue < 0
								lnValue   = -lnValue
								llChanged = .T.
							endif lnValue < 0
						endif .SpinnerHighValue < 0
		
		* -: change to negative.
		
					case tnKeyCode = 45 and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						llNoDefault = .T.
						.cSign      = iif(.cSign = '-', '', '-')
						do case
							case .SpinnerLowValue < 0
								lnValue   = -lnValue
								llChanged = .T.
							case .cSign = '-'
					            .cSign = ''
						endcase
		
		* Decimal: change to decimal input.
		
					case tnKeyCode = asc('.') and inlist(tnShiftAltCtrl, 0, 1)
						nodefault
						llNoDefault = .T.
						if .lHasDecimal
							.lInDecimalPart = .T.
							lnAddSelStart = at('.', .InputMask) - .SelStart
							llChanged     = .T.
						endif .lHasDecimal
		
		* Home: move the cursor to the beginning.
		
					case tnKeyCode = 1
						nodefault
						.lInDecimalPart = not .lHasInteger
						lnAddSelStart   = -.SelStart
						llChanged       = .T.
		
		* End: move the cursor to the end.
		
					case tnKeyCode = 6
						nodefault
						.lInDecimalPart = .lHasDecimal
						lnAddSelStart   = len(.InputMask) - .SelStart + 1
						llChanged       = .T.
		
		* Left arrow: move the cursor to the left.
		
					case tnKeyCode = 19
						nodefault
						lnAddSelStart = -1
						llChanged     = .T.
		
		* Right arrow: move the cursor to the right.
		
					case tnKeyCode = 4
						nodefault
						lnAddSelStart = 1
						llChanged     = .T.
		
		* Ctrl-UpArrow: set the maximum value.
		
					case tnKeyCode = 141 and tnShiftAltCtrl = 2
						nodefault
						llNoDefault = .T.
						lnValue     = val(transform(.SpinnerHighValue, .cInputMask))
						.cSign      = iif(lnValue > 0, '', '-')
						llChanged   = .T.
		
		* Ctrl-DownArrow: set the minimum value.
		
					case tnKeyCode = 145 and tnShiftAltCtrl = 2
						nodefault
						llNoDefault = .T.
						lnValue     = val(transform(.SpinnerLowValue, .cInputMask))
						.cSign      = iif(lnValue > 0, '', '-')
						llChanged   = .T.
		
		* Don't do anything.
		
					otherwise
						llOtherwise = .T.
				endcase
		
		* If the value was changed, update the spinner's value and cursor position.
		
				if not llOtherwise and llChanged
					if (.cSign == '-' and lnValue > 0) or (.cSign == ''  and ;
						lnValue < 0)
						lnValue = -lnValue
					endif (.cSign == '-' ...
					lnPos     = .SelStart
					.Value    = lnValue
					.SelStart = lnPos
					.AdjustSelStart(lnAddSelStart)
				endif not llOtherwise ...
		
		* If we used a NODEFAULT and changed the value, fire InteractiveChange.
		
				if llNoDefault
					.InteractiveChange()
				endif llNoDefault
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE lsaveanchor_assign
		lparameters tlSaveAnchor
		do case
			case tlSaveAnchor and This.nSavedAnchor > 0 and This.Anchor = 0
			case tlSaveAnchor
				This.nSavedAnchor = This.Anchor
				This.Anchor       = 0
			otherwise
				This.Anchor = This.nSavedAnchor
		endcase
		
	ENDPROC

	PROCEDURE nhighvalue_assign
		lparameters tnValue
		with This
			.nHighValue = tnValue
			.InputMask  = ''
			.SetCalcValues()
			if .lCalculator
				.AdjustSelStart(0)
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE nlowvalue_assign
		lparameters tnValue
		This.nLowValue = tnValue
		This.SetCalcValues()
		
	ENDPROC

	PROCEDURE onformchange		&& Fired when the lChanged property of the form changes if lNotifyOnFormChange is .T.
		* Refresh the control when something in the form changes.
		
		This.Refresh()
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		with This
		
		* If we're acting like a calculator, set SelStart to its saved value and then
		* make any necessary adjustments.
		
			if .lCalculator
				.SelStart = .nSelStart
				.AdjustSelStart(0)
			endif .lCalculator
		
		* Call a common method for handling changes.
		
			raiseevent(This, 'AnyChange')
		endwith
		
	ENDPROC

	PROCEDURE release		&& Releases the object
		* Release the object.
		
		release This
		
	ENDPROC

	PROCEDURE RightClick
		* Display a right-click menu.
		
		This.ShowMenu()
		
	ENDPROC

	PROCEDURE setcalcvalues		&& Handles changes to any of the "calculator" properties
		local lcValue, ;
			lnPos, ;
			lcMaxMask, ;
			lnLen, ;
			lnI, ;
			lcChar, ;
			lcMinMask, ;
			lnPos, ;
			lnMax, ;
			lnMin
		with This
		
		* If the InputMask is empty, initialize it with a default value.
		
			if empty(.InputMask) and not empty(.nHighValue)
				lcValue   = trim(padr(.nHighValue, 20))
				lnPos     = at('.', lcValue)
			   .InputMask = replicate('9', floor(log10(.nHighValue)) + 1) + ;
				   	iif(lnPos > 0, '.' + replicate('9', len(lcValue) - lnPos), '')
			endif empty(.InputMask) ...
		
		* Find the maximum mask by removing any special characters from InputMask.
		
			lcMaxMask = ''
			lnLen     = len(.InputMask)
			for lnI = 1 to lnLen
				lcChar = substr(.InputMask, lnI, 1)
				if isdigit(lcChar) or lcChar = '.'
					lcMaxMask = lcMaxMask + lcChar
				endif isdigit(lcChar) or lcChar = '.'
			next lnI
		
		* Save the maximum mask in cInputMask.
		
			.cInputMask = lcMaxMask
		
		* The minimum mask is obtained by removing the first character of the maximum
		* mask so we have one character for the sign.
		
			lcMinMask = right(lcMaxMask, len(lcMaxMask) - 1)
		
		* Set SpinnerHighValue and SpinnerLowValue to valid values. We won't set the
		* Keyboard equivalents because that prevents the user from canceling out of a
		* form without entering a valid value; instead, we'll trap that in Valid.
		
			lnMax = min(val(lcMaxMask),  .nHighValue, 2147483647)
			lnMin = max(-val(lcMinMask), .nLowValue,  -2147483647)
			.SpinnerHighValue = lnMax
			.SpinnerLowValue  = lnMin
		
		* If the values are only a single digit, turn off calculator mode.
		
			if lnMin >= 0 and lnMax <= 9
				.lCalculator = .F.
			endif lnMin >= 0 and lnMax <= 9
		
		* See if the mask has integer and decimal parts, and save it.
		
			if .lCalculator
				lnPos = at('.', .InputMask) 
				if lnPos > 0
					.lHasInteger = '9' $ left(.InputMask, lnPos - 1)
					.lHasDecimal = '9' $ substr(.InputMask, lnPos)
				else
					.lHasInteger = '9' $ This.InputMask
					.lHasDecimal = .F.
				endif lnPos > 0
			endif .lCalculator
		endwith
		
	ENDPROC

	PROCEDURE shortcutmenu		&& Populates the shortcut menu
		*==============================================================================
		* Method:			ShortcutMenu
		* Status:			Public
		* Purpose:			Populates the specified menu object
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2005 Stonefield Systems Group Inc.
		* Last revision:	08/24/2005
		* Parameters:		toMenu   - an object reference to a menu object
		*					tcObject - the name of the variable containing the object
		*						reference to this object
		* Returns:			.T.
		* Environment in:	oLocalizer may contain a reference to a localization object
		* Environment out:	additional items were added to the menu
		*==============================================================================
		
		lparameters toMenu, ;
			tcObject
		local lcCut, ;
			lcCopy, ;
			lcPaste, ;
			lcClear, ;
			lcSelect
		if type('oLocalizer.Name') = 'C'
			lcCut    = oLocalizer.GetLocalizedString('MENU_CUT')
			lcCopy   = oLocalizer.GetLocalizedString('MENU_COPY')
			lcPaste  = oLocalizer.GetLocalizedString('MENU_PASTE')
			lcClear  = oLocalizer.GetLocalizedString('MENU_CLEAR')
			lcSelect = oLocalizer.GetLocalizedString('MENU_SELECT_ALL')
		else
			lcCut    = 'Cu\<t'
			lcCopy   = '\<Copy'
			lcPaste  = '\<Paste'
			lcClear  = 'Cle\<ar'
			lcSelect = 'Se\<lect All'
		endif type('oLocalizer.Name') = 'C'
		with toMenu
			.AddMenuBar(lcCut,    "sys(1500, '_MED_CUT',   '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
				'CutXPSmall.bmp', '_med_cut')
			.AddMenuBar(lcCopy,   "sys(1500, '_MED_COPY',  '_MEDIT')", , , , , , ;
				'CopyXPSmall.bmp', '_med_copy')
			.AddMenuBar(lcPaste,  "sys(1500, '_MED_PASTE', '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
				'PasteXPSmall.bmp', '_med_paste')
			.AddMenuBar(lcClear,  "sys(1500, '_MED_CLEAR', '_MEDIT')", , , , ;
				'not ' + tcObject + '.Enabled or ' + tcObject + '.ReadOnly', , ;
				'_med_clear', '_med_clear')
			.AddMenuSeparator()
			.AddMenuBar(lcSelect, "sys(1500, '_MED_SLCTA', '_MEDIT')", , , , , , ;
				'_med_slcta', '_med_slcta')
		endwith
		
	ENDPROC

	PROCEDURE showmenu		&& Display a shortcut menu
		*==============================================================================
		* Method:			ShowMenu
		* Status:			Public
		* Purpose:			Displays a shortcut menu
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2004 Stonefield Systems Group Inc.
		* Last revision:	07/20/2004
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	SFMenu.VCX can be found
		* Environment out:	a menu may have been displayed
		*==============================================================================
		
		local lcLibrary
		private loObject, ;
			loHook, ;
			loForm
		with This
		
		* Define reference to objects we might have menu items from in case the action
		* for a bar is to call a method of an object, which can't be done using "This.
		* Method" since "This" isn't applicable in a menu.
		
			loObject = This
			loHook   = .oHook
			loForm   = Thisform
		
		* Define the menu if it hasn't already been defined.
		
			lcLibrary = 'SFMenu.vcx'
			if vartype(.oMenu) <> 'O' and file(lcLibrary)
				.oMenu = newobject('SFShortcutMenu', lcLibrary)
			endif vartype(.oMenu) <> 'O' ...
			if vartype(.oMenu) = 'O'
		
		* If there aren't any bars in the menu, have the ShortcutMenu method populate
		* it.
		
				if .oMenu.nBarCount = 0
					.ShortcutMenu(.oMenu, 'loObject')
		
		* Use the hook object (if there is one) to do any further population of the
		* menu.
		
					if vartype(loHook) = 'O' and pemstatus(loHook, 'ShortcutMenu', 5)
						loHook.ShortcutMenu(.oMenu, 'loHook')
					endif vartype(loHook) = 'O' ...
		
		* If desired, use the form's shortcut menu as well.
		
					if .lUseFormShortcutMenu and type('Thisform.Name') = 'C' and ;
						pemstatus(loForm, 'ShortcutMenu', 5)
						loForm.ShortcutMenu(.oMenu, 'loForm')
					endif .lUseFormShortcutMenu ...
				endif .oMenu.nBarCount = 0
		
		* Activate the menu if necessary.
		
				if .oMenu.nBarCount > 0
					.oMenu.ShowMenu()
				endif .oMenu.nBarCount > 0
			endif vartype(.oMenu) = 'O' ...
		endwith
		
	ENDPROC

	PROCEDURE updatecontrolsource		&& Updates the ControlSource with the new value
		*==============================================================================
		* Method:			UpdateControlSource
		* Status:			Public
		* Purpose:			Updates the ControlSource with the new value
		* Author:			Doug Hennig
		* Copyright:		(c) 2001-2006 Stonefield Systems Group Inc.
		* Last revision:	02/27/2006
		* Parameters:		none
		* Returns:			.T.
		* Environment in:	none
		* Environment out:	the ControlSource may have been updated
		*==============================================================================
		
		local lnPos, ;
			lcAlias, ;
			lcField
		with This
			lnPos = at('.', .ControlSource)
			if lnPos > 0 and not .Value == evaluate(.ControlSource)
				lcAlias = left(.ControlSource, lnPos - 1)
				lcField = substr(.ControlSource, lnPos + 1)
				if used(lcAlias)
					replace (lcField) with .Value in (lcAlias)
				else
					store .Value to (.ControlSource)
				endif used(lcAlias)
			endif lnPos > 0 ...
		endwith
		
	ENDPROC

	PROCEDURE Valid
		*==============================================================================
		* Method:			Valid
		* Status:			Public
		* Purpose:			Validate the Value
		* Author:			Doug Hennig
		* Copyright:		(c) 1996-2002 Stonefield Systems Group Inc.
		* Last revision:	08/20/2002
		* Parameters:		none
		* Returns:			.T. if the validation succeeded or we're not doing the
		*						validation
		* Environment in:	none
		* Environment out:	none
		*==============================================================================
		
		* If the Valid method is fired because the user clicked on a button with the
		* Cancel property set to .T. or if the button has an lCancel property (which
		* is part of the SFCommandButton base class) and it's .T., or if we're closing
		* the form, don't bother doing the rest of the validation.
		
		local loObject
		loObject = sys(1270)
		if (type('loObject.Cancel') = 'L' and loObject.Cancel) or ;
			(type('loObject.lCancel') = 'L' and loObject.lCancel) or ;
			(This.lSkipValidOnFormClose and ;
			type('Thisform.ReleaseType') = 'N' and Thisform.ReleaseType > 0)
			return .T.
		endif (type('loObject.lCancel') = 'L' ...
		
		* If the user tries to leave this control but a field validation rule failed,
		* we'll prevent them from doing so.
		
		if type('Thisform.lFieldRuleFailed') = 'L' and Thisform.lFieldRuleFailed
			Thisform.lFieldRuleFailed = .F.
			return 0
		endif type('Thisform.lFieldRuleFailed') = 'L' ...
		
		* Don't allow a value outside the valid range.
		
		if not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)
			return 0
		endif not between(This.Value, This.SpinnerLowValue, This.SpinnerHighValue)
		
		* Do the custom validation (this allows the developer to put custom validation
		* code into the Validation method rather than having to use code like the
		* following in the Valid method:
		*
		* dodefault()
		* custom code here
		* nodefault
		
		return This.Validation()
		
	ENDPROC

	PROCEDURE validation		&& An abstract method for custom validation code
		* Abstract method
		
	ENDPROC

ENDDEFINE

DEFINE CLASS testform AS sfform OF "source\sfctrls.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="sfcombobox1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="sfcheckbox1" UniqueID="" Timestamp="" />

	DoCreate = .T.
	Name = "testform"

	ADD OBJECT 'sfcheckbox1' AS sfcheckbox WITH ;
		Alignment = 0, ;
		Left = 75, ;
		Name = "sfcheckbox1", ;
		Top = 90, ;
		Visible = .T.
		*< END OBJECT: ClassLib="source\sfctrls.vcx" BaseClass="checkbox" />

	ADD OBJECT 'sfcombobox1' AS sfcombobox WITH ;
		Left = 54, ;
		Name = "sfcombobox1", ;
		Top = 44, ;
		Visible = .T.
		*< END OBJECT: ClassLib="source\sfctrls.vcx" BaseClass="combobox" />

ENDDEFINE
